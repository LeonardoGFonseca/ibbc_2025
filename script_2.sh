#!/bin/bash
# script_2.sh: Universal Pipeline 

# 'set -e': Exit immediately if any command exits with a non-zero status.
# 'set -o pipefail': Prevents errors in a pipeline
set -e
set -o pipefail

# Error trap function: Runs if the script crashes.
error_handler() { 
    echo "" 
    echo "CRITICAL ERROR! The script has stopped."
    echo "Check the global log: $GLOBAL_LOG"
    exit 1
}

# Activates the trap for any error signal (ERR)
trap 'error_handler' ERR


# 1. Location and Path Detection

CURRENT_DIR=$(pwd)

# Gets the physical location of the script file, resolving symlinks if needed.
SCRIPT_LOC="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"

# Detect Project Root
# Checks if we are running from the root or from inside '5_scripts'.
if [ -d "$CURRENT_DIR/1_raw_data" ]; then PROJECT_ROOT="$CURRENT_DIR"
elif [ -d "$SCRIPT_LOC/../1_raw_data" ]; then PROJECT_ROOT="$(dirname "$SCRIPT_LOC")"
else 
    # Ask user manually if auto-detection fails
    read -p "Path to project root: " PROJECT_ROOT; 
fi

# Define absolute paths for all directories
LOGS_DIR="$PROJECT_ROOT/4_logs"
RAW_DATA="$PROJECT_ROOT/1_raw_data"
QC_DIR="$PROJECT_ROOT/2_quality_control"
TRIMMED_DIR="$PROJECT_ROOT/3_trimmed_data"
SCRIPTS_DIR="$PROJECT_ROOT/5_scripts"
CONFIG_DIR="$LOGS_DIR/fastp" 

# Ensure directories exist (failsafe)
mkdir -p "$LOGS_DIR" "$CONFIG_DIR" "$QC_DIR" "$TRIMMED_DIR"

# Global Logging System
GLOBAL_LOG="$LOGS_DIR/pipeline_execution_$(date +%Y%m%d_%H%M%S).log"
exec > >(tee -a "$GLOBAL_LOG") 2>&1

echo " START OF EXECUTION: $(date)"
echo " Global Log: $GLOBAL_LOG"

# 2. Environment and Threads

# Ask how many threads we want
echo "--- Configuration ---"
echo -n "Threads [4]: "
read -r USER_THREADS < /dev/tty 

# Regex check: if empty or not a number, default to 4.
if [[ -z "$USER_THREADS" || ! "$USER_THREADS" =~ ^[0-9]+$ ]]; then THREADS=4; else THREADS=$USER_THREADS; fi
echo ">> Using $THREADS threads."

# Check if 'fastp' is activated. If not, ask for Conda environment.
if ! command -v fastp &> /dev/null; then
    echo "Missing tools."
    echo -n "Conda environment (ENTER to skip): "
    read -r ENV_NAME < /dev/tty
    if [ -n "$ENV_NAME" ]; then
        CONDA_BASE=$(conda info --base 2>/dev/null || echo "")
        if [ -n "$CONDA_BASE" ] && [ -f "$CONDA_BASE/etc/profile.d/conda.sh" ]; then
            source "$CONDA_BASE/etc/profile.d/conda.sh"
            conda activate "$ENV_NAME"
            echo "Environment activated."
        fi
    fi
fi

# 3. FastQC and MultiQC Raw Data

echo ""
echo "PHASE 1: INITIAL DIAGNOSTICS"
echo ">> FastQC Raw..."
# Runs FastQC on all .fastq files.
fastqc "$RAW_DATA"/*.fastq* -o "$QC_DIR/fastqc_raw/" -t "$THREADS"

echo ">> MultiQC Raw..."
multiqc "$QC_DIR/fastqc_raw" -o "$QC_DIR/multiqc_raw"

# 4. FastP Decision

# Ask what option to FastP we want
echo ""
echo "TRIMMING DEFINITION"
echo "1) Default (-q 20 -l 75)"
echo "2) Optimized (script_3.sh)"
echo "3) Manual"
echo -n "Option: "
read -r MODE < /dev/tty

PARAMS="-q 20 -l 75"

# If we chose the 2 option, redirect to script_3.sh
if [ "$MODE" == "2" ]; then
    # Locates script_3.sh
    if [ -f "$SCRIPTS_DIR/script_3.sh" ]; then S3="$SCRIPTS_DIR/script_3.sh"
    elif [ -f "$PROJECT_ROOT/script_3.sh" ]; then S3="$PROJECT_ROOT/script_3.sh"
    else S3="./script_3.sh"; fi

    if [ -f "$S3" ]; then
        echo ">> Calling Decision Model..."
        # Runs script_3 and captures its specific output to a separate log
        MODEL_RUN_LOG="$LOGS_DIR/fastp/model_execution_full.log"
        echo "--- Start of Model Execution: $(date) ---" > "$MODEL_RUN_LOG"
        
        bash "$S3" "$QC_DIR/fastqc_raw" 2>&1 | tee -a "$MODEL_RUN_LOG"
        
        # Reads the configuration generated by Script 3
        if [ -f "$CONFIG_DIR/.fastp_params.conf" ]; then
            PARAMS=$(cat "$CONFIG_DIR/.fastp_params.conf")
            echo "FINAL PARAMETERS APPLIED: $PARAMS"
        else 
            echo "Config error. Using Default."
        fi
    else 
        echo "Script 3 not found. Using Default."
    fi
elif [ "$MODE" == "3" ]; then
    echo -n "Manual parameters: "
    read -r PARAMS < /dev/tty
    echo "Manual: $PARAMS"
fi

# 5. Sample Selection

echo ""
echo "EXECUTION SCOPE"
echo "Do you want to process all samples or only a specific one?"
# Select all samples or select only one.
echo "1) All samples (Default)"
echo "2) Only one specific sample"
echo -n "Option: "
read -r SCOPE < /dev/tty

TARGET_FILES=""

if [ "$SCOPE" == "2" ]; then
    echo -n "Enter base sample name: "
    read -r SAMPLE_TARGET < /dev/tty
    
    # Look for matching files
    TARGET_FILES=$(find "$RAW_DATA" -name "${SAMPLE_TARGET}*_R1*.fastq*")
    
    if [ -z "$TARGET_FILES" ]; then
        echo "ERROR: No sample found with name '$SAMPLE_TARGET' in 1_raw_data/"
        exit 1
    fi
    echo ">> Surgical Mode Enabled: Processing only $SAMPLE_TARGET"
else
    # Select all R1 files
    TARGET_FILES="$RAW_DATA/*_R1*.fastq*"
    echo ">> Batch Mode Enabled: Processing all samples."
fi


# 6. Trimming with FastP

echo ""
echo "FastP Trimming..."

# Loop iterates over the list of files defined above
for R1_FILE in $TARGET_FILES; do
    # Check if file exists (handles case where folder is empty)
    [ -e "$R1_FILE" ] || continue
    
    # BASENAME extracts filename from path
    BASENAME=$(basename "$R1_FILE")
    # Replaces first instance of _R1 with _R2 to find the pair.
    R2_FILENAME="${BASENAME/_R1/_R2}"
    R2_FILE="$RAW_DATA/$R2_FILENAME"
    SAMPLE_NAME="${BASENAME%.fastq*}"

    echo "   -> Processing: $SAMPLE_NAME"
    if [ ! -f "$R2_FILE" ]; then 
        echo "Missing R2: $R2_FILENAME"
        exit 1
    fi

    # Run FastP
    fastp -i "$R1_FILE" -I "$R2_FILE" \
          -o "$TRIMMED_DIR/${SAMPLE_NAME}_trimmed_R1.fastq.gz" \
          -O "$TRIMMED_DIR/${SAMPLE_NAME}_trimmed_R2.fastq.gz" \
          -j "$LOGS_DIR/fastp/${SAMPLE_NAME}.json" \
          -h "$LOGS_DIR/fastp/${SAMPLE_NAME}.html" \
          $PARAMS --thread "$THREADS"
done

# 7. Final FastQC and MultiQC

echo "FastQC Trimmed..."
fastqc "$TRIMMED_DIR"/*.fastq* -o "$QC_DIR/fastqc_trimmed/" -t "$THREADS"

echo "MultiQC Final..."
multiqc "$PROJECT_ROOT" -o "$QC_DIR/multiqc_final"

echo ""
echo "COMPLETED!"
echo "Global Log: $GLOBAL_LOG"